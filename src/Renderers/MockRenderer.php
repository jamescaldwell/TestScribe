<?php
/**
 *
 */

namespace Box\TestScribe\Renderers;

use Box\TestScribe\MockClass;
use Box\TestScribe\Utils\ArrayUtil;
use ReflectionClass;

/**
 * Class MockRenderer
 * @package Box\TestScribe\Renderers
 *
 * Generate statements for mock objects.
 *
 * @var MockAllMethodExpectationsRenderer
 */
class MockRenderer
{
    /** @var MockAllMethodExpectationsRenderer */
    private $mockAllMethodExpectationsRenderer;

    /**
     * @param \Box\TestScribe\Renderers\MockAllMethodExpectationsRenderer $mockAllMethodExpectationsRenderer
     */
    function __construct(
        MockAllMethodExpectationsRenderer $mockAllMethodExpectationsRenderer
    )
    {
        $this->mockAllMethodExpectationsRenderer = $mockAllMethodExpectationsRenderer;
    }

    /**
     * @param \Box\TestScribe\MockClass $mock
     * @param string                              $constructorArgumentAsStringInCode
     * @param string                              $constructorArgumentMockingStatement
     *   mocking statements for objects in the constructor.
     *
     * @return string
     */
    public function renderPartialMock(
        MockClass $mock,
        $constructorArgumentAsStringInCode,
        $constructorArgumentMockingStatement
    )
    {
        $statements = $this->renderAMockInternal(
            true,
            $mock,
            $constructorArgumentAsStringInCode,
            $constructorArgumentMockingStatement
        );

        return $statements;
    }

    /**
     * @param \Box\TestScribe\MockClass $mock
     *
     * @return string
     */
    public function renderAMock(
        MockClass $mock
    )
    {
        $statements = $this->renderAMockInternal(
            false,
            $mock,
            '',
            ''
        );

        return $statements;
    }

    /**
     * @param bool                                $isPartialMock
     * @param \Box\TestScribe\MockClass $mock
     *
     * @param string                              $constructorArgumentAsStringInCode
     *   if the string is not empty it means partial mocking is requested.
     *
     * @param string                              $constructorArgumentMockingStatement
     *   mocking statements for any objects in the constructor.
     *
     * @return string
     */
    private function renderAMockInternal(
        $isPartialMock,
        MockClass $mock,
        $constructorArgumentAsStringInCode,
        $constructorArgumentMockingStatement
    )
    {
        $isStaticMock = $mock->isStaticMock();
        if ($isStaticMock) {
            $mockMethodName = 'shmock_class';
        } else {
            $mockMethodName = 'shmock';
        }

        $mockObjectName = $mock->getMockObjectName();
        $className = $mock->getClassNameBeingMocked();
        $classNameAsStringInCode = var_export($className, true);
        $bodyStatements = $this->renderMockObjectBody($mock);

        $configureMockingPropertiesStatements = "\$shmock->order_matters();";
        if ($isStaticMock) {
            $mockObjectTypeString = 'ClassBuilderStaticClass';
            // @TODO (ryang 1/29/15) : re-evaluate after
            // https://github.com/box/shmock/issues/7 is fixed.

            // Due to the bug above, dont_preserve_original_methods
            // will interfere will order_matters and cause the generated tests to fail
            // Not calling dont_preserve_original_methods will cause 
            // the original methods not overwritten to be preserved.
        } else {
            $mockObjectTypeString = 'PHPUnitMockInstance';
            if ($isPartialMock) {
                $configureMockingPropertiesStatements = ArrayUtil::joinNonEmptyStringsWithNewLine(
                    [
                        $configureMockingPropertiesStatements,
                        $constructorArgumentMockingStatement,
                        "\$shmock->set_constructor_arguments($constructorArgumentAsStringInCode);"
                    ],
                    2
                );
            } else {
                if ($this->isInterfaceOrAbstract($className)) {
                    // When the class being mocked is an abstract class or an interface
                    // all original methods have to be overwritten. 
                    // Otherwise the mocked object generated by shmock will have syntax errors
                    // when running the generated tests. 
                    $doNotPreserveOriginalMethodsStatement = "\$shmock->dont_preserve_original_methods();";
                } else {
                    // @TODO (ryang 4/21/15) : re-evaluate after
                    // https://github.com/box/shmock/issues/8 is fixed.
                    $doNotPreserveOriginalMethodsStatement = '';
                }
                $configureMockingPropertiesStatements = ArrayUtil::joinNonEmptyStringsWithNewLine(
                    [
                        $configureMockingPropertiesStatements,
                        "\$shmock->disable_original_constructor();",
                        $doNotPreserveOriginalMethodsStatement
                    ],
                    1
                ) ;
            }
        }

        $indentUtilObj = new IndentationUtil();
        $mockPropertyStatements = $indentUtilObj->indent(2, $configureMockingPropertiesStatements);
        $combinedBody = ArrayUtil::joinNonEmptyStringsWithNewLine(
            [$mockPropertyStatements, $bodyStatements],
            2
        );

        $mockedObjectString = <<<TAG
/** @var $className \$$mockObjectName */
\$$mockObjectName = \$this->$mockMethodName(
    $classNameAsStringInCode,
    function (
        /** @var $className|\\Shmock\\$mockObjectTypeString \$shmock */
        \$shmock
    ) {
$combinedBody
    }
);
TAG;

        return $mockedObjectString;
    }

    /**
     * @param string $fullClassName
     *
     * @return bool
     */
    private function isInterfaceOrAbstract($fullClassName)
    {
        $reflectionClass = new ReflectionClass($fullClassName);
        $rc = $reflectionClass->isInterface() || $reflectionClass->isAbstract();

        return $rc;
    }

    /**
     * Generate mock object expectations statements.
     *
     * @param \Box\TestScribe\MockClass $mock
     *
     * @return string
     */
    private function renderMockObjectBody(MockClass $mock)
    {
        $mockReturnObjectStatements = $this->renderMockedReturnValue(
            $mock
        );
        $methodExpectations = $this->mockAllMethodExpectationsRenderer->renderMethodExpectations($mock);
        $body = ArrayUtil::joinNonEmptyStringsWithNewLine(
            [$mockReturnObjectStatements ,  $methodExpectations],
            2
        );

        $indentUtilObj = new IndentationUtil();
        $shiftedBody = $indentUtilObj->indent(2, $body);

        return $shiftedBody;
    }

    /**
     * @param \Box\TestScribe\MockClass $mock
     *
     * @return string
     *
     * Define this method in a separate class causes circular dependencies.
     * i.e. these two methods depend on each other.
     */
    public function renderMockedReturnValue(MockClass $mock)
    {
        $statementsArray = [];

        $mocks = $mock->getMockedReturnValues();
        if ($mocks) {
            $statementsArray[] = "// Set up mocks of return values.";

            foreach ($mocks as $mockedReturnValueObj) {
                $oneMockStatement = $this->renderAMock($mockedReturnValueObj);
                $statementsArray[]= $oneMockStatement;
            }
        }
        $statementsString = ArrayUtil::joinNonEmptyStringsWithNewLine(
            $statementsArray,
            2
        );

        return $statementsString;
    }
}
